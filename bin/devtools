#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

usage() {
  cat <<'EOF'
Uso:
  devtools apps sync [--only <app>]

Comandos:
  apps sync   Sincroniza repos de apps en <repo-root>/apps leyendo <repo-root>/.devtools/config/apps.yaml

Opciones:
  --only <app>   Sincroniza solo una app por nombre

Notas:
  - DEVTOOLS_DRY_RUN=1: solo imprime acciones (sin clone/fetch/pull)
EOF
}

log_info() { echo "ℹ️  $*"; }
log_ok() { echo "✅ $*"; }
log_warn() { echo "⚠️  $*"; }
log_error() { echo "❌ $*" >&2; }

die() {
  log_error "$*"
  exit 1
}

strip_quotes() {
  local value="$1"
  value="${value#\"}"
  value="${value%\"}"
  value="${value#\'}"
  value="${value%\'}"
  echo "$value"
}

resolve_repo_root_or_die() {
  git rev-parse --show-toplevel 2>/dev/null || die "Debes ejecutar este comando dentro de un repositorio Git."
}

is_dry_run() {
  [[ "${DEVTOOLS_DRY_RUN:-0}" == "1" ]]
}

default_repo_for_app() {
  local app_name="$1"
  local owner="${DEVTOOLS_APPS_SYNC_OWNER:-elrincondeldetective}"
  echo "git@github.com:${owner}/${app_name}.git"
}

derive_name_from_path() {
  local app_path="$1"
  app_path="$(strip_quotes "$app_path")"
  app_path="${app_path%/}"

  if [[ "$app_path" =~ ^apps/([^/]+) ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0
  fi

  if [[ "$app_path" == */* ]]; then
    echo "${app_path##*/}"
    return 0
  fi

  echo "$app_path"
}

# Pobla arreglo global APPS_ENTRIES con elementos "name|repo"
parse_apps_config_or_die() {
  local config_file="$1"
  [[ -f "$config_file" ]] || die "Falta .devtools/config/apps.yaml (ruta esperada: ${config_file})"

  APPS_ENTRIES=()

  local in_container=0
  local container_indent=-1
  local item_name=""
  local item_repo=""
  local item_path=""
  local line_no=0

  finalize_item_or_die() {
    if [[ -z "$item_name" && -n "$item_path" ]]; then
      item_name="$(derive_name_from_path "$item_path")"
    fi

    if [[ -n "$item_name" || -n "$item_repo" || -n "$item_path" ]]; then
      [[ -n "$item_name" ]] || die "Config inválida en ${config_file}: item incompleto cerca de línea ${line_no} (falta name/id)."

      if [[ -z "$item_repo" ]]; then
        item_repo="$(default_repo_for_app "$item_name")"
      fi

      APPS_ENTRIES+=("${item_name}|${item_repo}")
    fi

    item_name=""
    item_repo=""
    item_path=""
  }

  while IFS= read -r raw_line || [[ -n "$raw_line" ]]; do
    line_no=$((line_no + 1))

    local line="${raw_line%$'\r'}"
    local trimmed
    trimmed="$(printf '%s' "$line" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
    local indent_prefix="${line%%[![:space:]]*}"
    local indent_len="${#indent_prefix}"

    [[ -z "$trimmed" ]] && continue
    [[ "${trimmed:0:1}" == "#" ]] && continue

    if [[ "$trimmed" =~ ^(apps|repos|repositories|projects):[[:space:]]*$ ]]; then
      finalize_item_or_die
      in_container=1
      container_indent="$indent_len"
      continue
    fi

    if [[ "$in_container" -eq 1 && "$indent_len" -le "$container_indent" ]]; then
      finalize_item_or_die
      in_container=0
      container_indent=-1
    fi

    # Soporta mapa bajo apps/repos/repositories/projects:
    # apps:
    #   pmbok:
    #     repo: git@...
    if [[ "$in_container" -eq 1 && "$indent_len" -eq $((container_indent + 2)) && "$trimmed" =~ ^([A-Za-z0-9._-]+):[[:space:]]*$ ]]; then
      finalize_item_or_die
      item_name="$(strip_quotes "${BASH_REMATCH[1]}")"
      continue
    fi

    if [[ "$trimmed" =~ ^-[[:space:]]*name:[[:space:]]*(.+)$ ]]; then
      finalize_item_or_die
      item_name="$(strip_quotes "${BASH_REMATCH[1]}")"
      item_repo=""
      item_path=""
      continue
    fi

    if [[ "$trimmed" =~ ^-[[:space:]]*id:[[:space:]]*(.+)$ ]]; then
      finalize_item_or_die
      item_name="$(strip_quotes "${BASH_REMATCH[1]}")"
      item_repo=""
      item_path=""
      continue
    fi

    if [[ "$trimmed" =~ ^name:[[:space:]]*(.+)$ ]]; then
      item_name="$(strip_quotes "${BASH_REMATCH[1]}")"
      continue
    fi

    if [[ "$trimmed" =~ ^id:[[:space:]]*(.+)$ ]]; then
      item_name="$(strip_quotes "${BASH_REMATCH[1]}")"
      continue
    fi

    if [[ "$trimmed" =~ ^path:[[:space:]]*(.+)$ ]]; then
      item_path="$(strip_quotes "${BASH_REMATCH[1]}")"
      continue
    fi

    if [[ "$trimmed" =~ ^repo:[[:space:]]*(.+)$ ]]; then
      item_repo="$(strip_quotes "${BASH_REMATCH[1]}")"
      continue
    fi

    if [[ "$trimmed" =~ ^repository:[[:space:]]*(.+)$ ]]; then
      item_repo="$(strip_quotes "${BASH_REMATCH[1]}")"
      continue
    fi

    if [[ "$trimmed" =~ ^repo_url:[[:space:]]*(.+)$ ]]; then
      item_repo="$(strip_quotes "${BASH_REMATCH[1]}")"
      continue
    fi

    if [[ "$trimmed" =~ ^url:[[:space:]]*(.+)$ ]]; then
      item_repo="$(strip_quotes "${BASH_REMATCH[1]}")"
      continue
    fi

    if [[ "$trimmed" =~ ^git:[[:space:]]*(.+)$ ]]; then
      item_repo="$(strip_quotes "${BASH_REMATCH[1]}")"
      continue
    fi
  done < "$config_file"

  finalize_item_or_die

  [[ "${#APPS_ENTRIES[@]}" -gt 0 ]] || die "Config inválida en ${config_file}: no se encontraron apps. Formas soportadas: apps/repos/repositories/projects como lista (name|id + repo opcional), mapa (clave -> repo) o lista top-level."
}

sync_app_entry() {
  local workspace_root="$1"
  local app_name="$2"
  local app_repo="$3"
  local app_dest="${workspace_root}/apps/${app_name}"

  if [[ -d "${app_dest}/.git" ]]; then
    if is_dry_run; then
      log_warn "DRY-RUN: update ${app_name} (${app_dest}) [git fetch --prune + git pull --ff-only]"
      return 0
    fi

    log_info "Update ${app_name}: ${app_dest}"
    git -C "$app_dest" fetch --prune
    git -C "$app_dest" pull --ff-only
    log_ok "App actualizada: ${app_name}"
    return 0
  fi

  if is_dry_run; then
    if [[ -e "$app_dest" && ! -d "${app_dest}/.git" ]]; then
      log_warn "DRY-RUN: destino existente no-git para ${app_name}: ${app_dest}. Se intentaría clonar encima (revisar manualmente)."
      log_warn "DRY-RUN: clone ${app_repo} -> ${app_dest}"
      return 0
    fi
    log_warn "DRY-RUN: clone ${app_repo} -> ${app_dest}"
    return 0
  fi

  if [[ -e "$app_dest" && ! -d "${app_dest}/.git" ]]; then
    die "Destino inválido para ${app_name}: ${app_dest} existe pero no es un repo Git."
  fi

  log_info "Clone ${app_name}: ${app_repo} -> ${app_dest}"
  mkdir -p "$(dirname "$app_dest")"
  git clone "$app_repo" "$app_dest"
  log_ok "App clonada: ${app_name}"
}

apps_sync() {
  local only_app=""

  while (( $# )); do
    case "$1" in
      --only)
        only_app="${2:-}"
        [[ -n "$only_app" ]] || die "Falta valor para --only"
        shift 2
        ;;
      -h|--help)
        usage
        return 0
        ;;
      *)
        die "Opción desconocida para 'apps sync': $1"
        ;;
    esac
  done

  local repo_root
  repo_root="$(resolve_repo_root_or_die)"

  local config_file="${repo_root}/.devtools/config/apps.yaml"
  parse_apps_config_or_die "$config_file"

  log_info "Repo raíz: ${repo_root}"
  log_info "Config apps: ${config_file}"

  local selected_entries=()
  local entry
  for entry in "${APPS_ENTRIES[@]}"; do
    local app_name="${entry%%|*}"
    local app_repo="${entry#*|}"

    [[ -n "$app_name" ]] || die "Config inválida en ${config_file}: item sin name."
    [[ -n "$app_repo" ]] || die "Config inválida en ${config_file}: item sin repo (app=${app_name})."

    if [[ -n "$only_app" && "$app_name" != "$only_app" ]]; then
      continue
    fi

    selected_entries+=("${entry}")
  done

  if [[ -n "$only_app" && "${#selected_entries[@]}" -eq 0 ]]; then
    die "La app '${only_app}' no existe en ${config_file}."
  fi

  local selected_count="${#selected_entries[@]}"
  for entry in "${selected_entries[@]}"; do
    local app_name="${entry%%|*}"
    local app_repo="${entry#*|}"
    sync_app_entry "$repo_root" "$app_name" "$app_repo"
  done

  log_ok "apps sync completado (${selected_count} apps)."
}

main() {
  local cmd="${1:-}"
  local subcmd="${2:-}"

  case "$cmd" in
    apps)
      case "$subcmd" in
        sync)
          shift 2
          apps_sync "$@"
          ;;
        -h|--help|help|"")
          usage
          ;;
        *)
          die "Subcomando desconocido: apps ${subcmd}"
          ;;
      esac
      ;;
    -h|--help|help|"")
      usage
      ;;
    *)
      die "Comando desconocido: ${cmd}. Usa: devtools apps sync [--only <app>]"
      ;;
  esac
}

main "$@"
